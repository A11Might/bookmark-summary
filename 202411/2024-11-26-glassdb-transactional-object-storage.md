# Glassdb: transactional object storage
- URL: https://blog.mbrt.dev/posts/transactional-object-storage/
- Added At: 2024-11-26 00:33:46
- [Link To Text](2024-11-26-glassdb-transactional-object-storage_raw.md)

## TL;DR
作者在云环境中遇到数据持久化问题，提出利用对象存储（如S3）构建事务性数据库GlassDB。通过性能测试和成本分析，发现其在某些场景下具有优势。设计了无服务器组件和SQLite结合的简单数据库，但面临单对象方法的性能限制。探讨了分布式事务、隔离与一致性问题，最终选择严格两阶段锁定算法实现严格可序列化。通过多种优化手段提升性能，并进行了性能测试。总结指出GlassDB在特定场景下有优势，未来计划移植到其他云平台。

## Summary
1. **背景与动机**：
   - **云应用的挑战**：作者在云环境中使用无状态应用时，发现持久化数据在请求之间存在问题，需要在廉价、强一致性和可移植性之间做出选择。
   - **解决方案思考**：作者考虑通过对象存储（如AWS S3）来解决可移植性和缺乏事务的问题，因为对象存储具有强一致性、普遍性和廉价的特点。

2. **现有数据库的局限**：
   - **云数据库的缺点**：作者列举了Google Cloud、AWS等云服务提供的数据库选项，如Google SQL for Postgres、Spanner、Datastore、RDS和DynamoDB，指出它们在成本、一致性、可移植性等方面存在不足。

3. **GlassDB的构思**：
   - **对象存储的利用**：作者决定利用Google Cloud Storage和AWS S3的强一致性特性，将其转化为事务性数据库。
   - **性能测试**：作者进行了读写100KiB对象的测试，结果显示读取时间为63.1ms，写入时间为105ms，元数据操作时间为41.3ms，虽然比本地SQLite慢10倍，但在许多场景下是可以接受的。

4. **成本分析**：
   - **与传统数据库的比较**：作者比较了使用Google Cloud SQL的最便宜实例与对象存储的成本，发现对于不频繁或突发流量，对象存储在成本上是有优势的。

5. **最简单的数据库设计**：
   - **无服务器组件**：作者设计了一个没有服务器组件的最简单数据库，仅依赖客户端库和对象存储。
   - **SQLite的利用**：通过将SQLite数据库序列化为对象，并在每次事务中下载、执行事务、条件写回对象存储，实现了基本的事务性数据库。

6. **单对象方法的局限**：
   - **性能问题**：每次事务都需要下载和上传整个数据库，导致性能低下，且客户端在每次事务中都会发生冲突，缺乏并行性。
   - **更新限制**：Google Cloud Storage官方限制每秒只能对同一对象进行一次更新，进一步限制了数据库的性能。

7. **分布式事务的挑战**：
   - **多对象事务**：作者探讨了在多个对象之间实现ACID事务的挑战，指出对象存储对单个对象的操作是强一致的，但对涉及多个对象的操作则不是原子的。
   - **分布式事务算法**：作者研究了分布式事务算法，考虑了最小化写操作的算法，以保持“正确性”。

8. **隔离与一致性**：
   - **ACID属性**：作者讨论了ACID属性中的隔离性和一致性，指出不同数据库在隔离级别上的差异，以及在分布式系统中这些概念的复杂性。
   - **Jepsen的图表**：作者参考了Jepsen的图表，解释了隔离和一致性级别的层次结构，强调了严格可序列化（Strict Serializable）是最强的隔离级别。

9. **隔离级别的权衡**：
   - **弱隔离级别**：作者讨论了弱隔离级别允许更多优化，但也允许更多异常，需要应用程序开发者自行处理。
   - **强隔离级别**：作者认为在性能足够的情况下，强隔离级别是更好的选择，因为开发者的时间比机器时间更宝贵。

10. **无隔离的实现**：
    - **基本算法**：作者提出了一个简单的无隔离事务算法，通过S3和GCS的强一致性实现了线性化一致性，但没有提供基本的隔离。

11. **接口设计**：
    - **SQL接口**：作者考虑了通过SQLite提供熟悉的SQL接口，但由于数据分布在多个对象中，实现变得更加复杂。
    - **键值存储**：作者参考了FoundationDB和CockroachDB等现代数据库，决定采用事务性键值存储的核心接口。

12. **选择算法**：
    - **严格两阶段锁定（S2PL）**：作者选择了S2PL算法，以保证可序列化隔离，并结合GCS的线性化一致性，实现严格可序列化。

13. **实现细节**：
    - **锁机制**：作者详细描述了如何在GCS对象的元数据中实现锁机制，包括读锁和写锁的实现。
    - **提交机制**：作者讨论了如何通过事务日志实现原子提交，确保事务的持久性。
    - **死锁与崩溃处理**：作者介绍了通过TTL（Time-To-Live）解决死锁问题，并通过事务日志处理崩溃后的恢复。

14. **性能优化**：
    - **事务日志**：作者通过为每个事务分配不同的日志对象，避免了全局同步点，提高了并行性。
    - **乐观锁定**：作者采用了乐观锁定算法，优化了低数据争用工作负载的性能。
    - **只读事务**：作者讨论了只读事务的优化，通过避免锁定和事务日志的写入，提高了只读事务的性能。
    - **单键读-修改-写**：作者通过使用对象存储的原生CAS操作，优化了单键事务的性能。
    - **本地缓存**：作者引入了本地LRU缓存，减少了重复读取，提高了性能。

15. **性能测试**：
    - **吞吐量**：作者进行了性能测试，结果显示在低冲突工作负载下，吞吐量随事务数量线性增长。
    - **延迟**：作者指出延迟虽然高于大多数数据库，但在高并发下保持相对平稳，除非在高争用情况下。

16. **总结与展望**：
    - **GlassDB的局限**：作者承认GlassDB在性能上不如传统数据库，但在某些特定场景下是有优势的。
    - **未来工作**：作者提到尚未将GlassDB移植到其他云提供商，如AWS S3，并表示这将是未来的工作。
