# Research!rsc：编程语言内存模型（内存模型，第 2 部分） --- research!rsc: Programming Language Memory Models (Memory Models, Part 2)
- URL: https://research.swtch.com/plmm
- Added At: 2024-12-13 00:34:22
- [Link To Text](2024-12-13-research!rsc：编程语言内存模型（内存模型，第-2-部分）-----research!rsc-programming-language-memory-models-(memory-models,-part-2)_raw.md)

## TL;DR
文章讨论了编程语言内存模型在多线程程序中的重要性，解释了变量缓存、指令重排等问题，并介绍了原子变量、数据竞争和顺序一致性等概念。现代语言通过原子操作和同步机制确保程序正确执行，尽管硬件和编译器的优化带来了挑战。

## Summary
1. **编程语言内存模型的定义**：编程语言内存模型回答了并行程序在共享内存时可以依赖哪些行为的问题。例如，在C语言中，两个线程共享变量`x`和`done`，线程1写入`x`并设置`done`为1，线程2在`done`为0时循环，然后读取`x`。编程语言内存模型决定了程序是否能按预期完成并打印1。

2. **现代多线程语言的通用规则**：
   - **变量缓存问题**：如果`x`和`done`是普通变量，线程2的循环可能永远不会停止，因为编译器可能会将`done`加载到寄存器中并在整个循环中重复使用，而不会注意到线程1对`done`的修改。
   - **指令重排问题**：即使线程2的循环停止，它也可能打印`x`为0，因为编译器可能会根据优化启发式或代码生成过程中的数据结构遍历顺序重新排序读写操作。

3. **如何修复程序**：
   - **原子变量或操作**：现代语言提供了原子变量或原子操作来同步线程。如果将`done`设为原子变量，程序将按预期完成并打印1。
   - **原子变量的效果**：编译器必须确保线程1的写入`x`在写入`done`之前完成并可见，线程2必须在每次循环中重新读取`done`，并在读取`x`之前读取`done`。

4. **数据竞争与顺序一致性**：
   - **数据竞争**：在原始程序中，线程1和线程2可能在同一时刻对`x`进行读写，导致数据竞争。
   - **无数据竞争的顺序一致性**：现代语言保证无数据竞争的程序以顺序一致的方式执行，即不同线程的操作可以任意交错，但不会重新排序。

5. **原子变量的正确术语**：原子变量或操作应称为“同步原子”，因为它们不仅在数据库意义上是原子的，还能同步程序的其他部分，消除非原子数据的竞争。

6. **编程语言内存模型的细节**：
   - **原子变量的顺序保证**：不同语言对原子变量的顺序保证不同。
   - **原子与非原子操作的访问**：某些语言允许变量同时被原子和非原子操作访问。
   - **同步机制**：除了原子操作外，语言还提供了其他同步机制。
   - **无同步的原子操作**：某些语言提供了不进行同步的原子操作。
   - **数据竞争程序的保证**：有数据竞争的程序是否有任何保证。

7. **硬件内存模型的教训**：
   - **指令重排**：不同架构允许不同程度的指令重排，导致并行程序在不同架构上可能有不同的结果。
   - **顺序一致性**：顺序一致性是最容易理解的模型，但现代架构为了性能放弃了这种模型。
   - **测试用例（Litmus Tests）**：通过特定的测试用例可以比较不同内存模型的行为。

8. **编译器与优化**：
   - **编译器重排**：编译器可能会在生成最终代码时重新排序操作，导致程序行为与预期不符。
   - **编译器优化的限制**：编译器在多线程程序中不能随意重排操作，否则可能引入数据竞争。

9. **Java内存模型的历史**：
   - **原始Java内存模型（1996）**：Java是第一个尝试为多线程程序定义内存模型的主流语言，但存在严重缺陷，如volatile变量不进行同步。
   - **新Java内存模型（2004）**：Java 5.0引入了新的内存模型，采用了DRF-SC（数据竞争自由顺序一致性），并改进了对数据竞争程序的定义。

10. **C++11内存模型**：
    - **无数据竞争程序的保证**：C++11对有数据竞争的程序不提供任何保证，称为“DRF-SC或Catch Fire”。
    - **原子操作的类型**：C++11提供了三种原子操作：顺序一致、获取/释放和无同步（relaxed）。

11. **JavaScript内存模型**：
    - **SharedArrayBuffer**：JavaScript引入了`SharedArrayBuffer`，允许主线程和Web Workers共享可写内存，因此需要定义原子操作和内存模型。
    - **与C++的不同**：JavaScript只提供顺序一致的原子操作，并定义了数据竞争程序的行为，避免了“DRF-SC或Catch Fire”。

12. **总结与未来展望**：
    - **共同点**：所有语言都提供了顺序一致的同步原子操作，并保证无数据竞争的程序以顺序一致的方式执行。
    - **硬件支持**：处理器制造商开始支持顺序一致的原子操作，ARMv8和RISC-V等架构提供了直接支持。
    - **未来的挑战**：尽管已经进行了大量的研究和验证工作，但定义和形式化多线程程序的内存模型仍然是一个非常复杂和困难的问题。
