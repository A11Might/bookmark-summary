# Static search trees: 40x faster than binary search
- URL: https://curiouscoding.nl/posts/static-search-tree/
- Added At: 2025-01-02 00:16:47
- [Link To Text](2025-01-02-static-search-trees-40x-faster-than-binary-search_raw.md)

## TL;DR
本文探讨了如何优化在静态排序列表中查找大于等于给定值的最小元素的数据结构，主要应用于生物信息学中的 DNA 数据索引。通过引入 Eytzinger 布局、S 树、SIMD 指令、批处理和预取等技术，显著提升了查询性能，从二分查找的 1150ns/query 优化到 S 树的 27ns/query。未来工作包括进一步优化分区、插值搜索和数据压缩等。

## Summary
1. **问题描述**：
   - **输入**：一个包含 \(n\) 个 32 位无符号整数的排序列表 `vals: Vec<u32>`。
   - **输出**：一个支持查询 \(q\) 的数据结构，返回 `vals` 中大于等于 \(q\) 的最小元素，若不存在则返回 `u32::MAX`。
   - **优化目标**：优化吞吐量，即每秒能处理的独立查询数量。

2. **动机**：
   - **生物信息学应用**：用于高效索引 DNA 数据，如人类基因组（30 亿碱基对）。
   - **静态数据假设**：通常使用固定的参考基因组，因此假设输入数据是静态的。

3. **推荐阅读**：
   - **经典解决方案**：二分查找。
   - **相关论文**：Khuong 和 Morin 的《Array Layouts for Comparison-Based Searching》。
   - **S+ 树**：基于 Algorithmica 的静态 B 树介绍。

4. **二分查找与 Eytzinger 布局**：
   - **Eytzinger 布局**：将数据重新排序，使得二分查找的每一步所需的值在内存中紧密排列，从而有效利用缓存。
   - **性能对比**：Eytzinger 布局在数据超过 L3 缓存时比标准二分查找快 4 倍。

5. **Hugepages**：
   - **使用 2MB 大页**：减少 TLB 压力，提升大尺寸数据结构的性能。

6. **缓存行**：
   - **缓存行大小**：64 字节，包含 16 个 u32 值。
   - **优化思路**：通过存储多个树层在一个缓存行中，减少缓存行读取次数。

7. **S 树与 B 树**：
   - **B 树**：经典动态树结构，通常用于磁盘读取。
   - **S 树**：介于 B 树和 Eytzinger 布局之间的紧凑树结构。
   - **S+ 树**：在内部节点中重复存储所有值，简化查询过程。

8. **优化查找函数**：
   - **线性查找**：通过线性扫描找到第一个大于等于 \(q\) 的元素。
   - **自动向量化**：通过计数小于 \(q\) 的元素数量，避免分支预测失败。
   - **尾随零计数**：使用 SIMD 指令并行比较 16 个值，并通过尾随零计数找到第一个大于等于 \(q\) 的元素。
   - **Popcount**：通过计算小于 \(q\) 的元素数量，避免顺序依赖。
   - **手动 SIMD**：通过手动编写 SIMD 代码，减少指令数量，提升性能。

9. **优化搜索过程**：
   - **批处理**：同时处理多个查询，减少内存访问延迟。
   - **预取**：在处理当前节点时，预取下一个可能访问的节点。
   - **指针算术**：通过指针操作减少索引计算的开销。

10. **树布局优化**：
    - **左树**：在内部节点中存储左子树的最大值，减少查询路径。
    - **内存布局**：尝试不同的内存布局（如反向布局和完整布局），但未显著提升性能。
    - **节点大小**：尝试使用 15 个值每节点，减少乘法计算开销，但增加内存占用。

11. **前缀分区**：
    - **简单分区**：根据值的前 \(b\) 位将数据分区，减少树的高度。
    - **紧凑子树**：通过紧凑存储子树，减少内存占用。
    - **重叠树**：通过共享存储空间，减少内存浪费。
    - **前缀映射**：通过前缀映射快速定位查询所在的分区。

12. **多线程性能**：
    - **多线程优化**：使用 6 个线程时，查询时间从 27ns 降至 7ns，但受限于总内存带宽。

13. **结论**：
    - **性能提升**：从二分查找的 1150ns/query 优化到 S 树的 27ns/query，提升超过 40 倍。
    - **批处理与预取**：通过批处理和预取显著减少内存访问延迟。
    - **分区优化**：分区在某些情况下能提升性能，但复杂性较高，且对输入数据分布敏感。

14. **未来工作**：
    - **分支搜索**：通过分支处理不同大小的分区，减少查询步骤。
    - **插值搜索**：通过插值搜索减少内存访问次数。
    - **数据压缩**：通过压缩数据减少内存占用。
    - **返回原始索引**：扩展查询功能，返回原始数据中的索引。
    - **范围查询**：支持返回大于等于 \(q\) 和大于 \(q\) 的值，确定查询范围。
    - **排序查询**：通过排序查询，最大化节点重用，减少内存访问。
    - **后缀数组搜索**：将 S 树集成到后缀数组搜索中，快速确定查询范围。
